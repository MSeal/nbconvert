"""Utility for calling pandoc"""
# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import print_function, absolute_import

import subprocess
import warnings
import re
import os
import shutil
from io import TextIOWrapper, BytesIO

from nbconvert.utils.version import check_version
from ipython_genutils.py3compat import cast_bytes, which
from ipython_genutils.path import link_or_copy, ensure_dir_exists
try:
    # Python 2
    from urllib import pathname2url, url2pathname
except ImportError:
    # Python 3
    from urllib.request import pathname2url, url2pathname

from .exceptions import ConversionException
from .io import sensitive_filename_cleanup

_minimal_version = "1.12.1"
_maximal_version = "3.0.0"


def pandoc(source, fmt, to, extra_args=None, encoding='utf-8',
           relative_path_replacement=None, build_path_replacement=None):
    """Convert an input string using pandoc.

    Pandoc converts an input string `from` a format `to` a target format.

    Parameters
    ----------
    source : string
      Input string, assumed to be valid format `from`.
    fmt : string
      The name of the input format (markdown, etc.)
    to : string
      The name of the output format (html, etc.)
    extra_args : list (optional)
      Extra Pandoc command arguments.
    relative_path_replacement : string (optional)
      The path to use in replacing relative paths.
    build_path_replacement : string (optional)
      A path to copy files into and reference in any image paths.

    Returns
    -------
    out : unicode
      Output as returned by pandoc.

    Raises
    ------
    PandocMissing
      If pandoc is not installed.

    Any error messages generated by pandoc are printed to stderr.

    """
    cmd = ['pandoc', '-f', fmt, '-t', to]
    if extra_args:
        cmd.extend(extra_args)

    # This will raise an exception that will pop us out of here
    check_pandoc_version()

    # For markdown formats we can manipulate image paths to correct for latex issues
    if 'markdown' in fmt:
        source = replace_markdown_paths(
            source, relative_path_replacement, build_path_replacement)

    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    out, _ = p.communicate(cast_bytes(source, encoding))
    out = TextIOWrapper(BytesIO(out), encoding, 'replace').read()
    return out.rstrip('\n')


def get_pandoc_version():
    """Gets the Pandoc version if Pandoc is installed.

    If the minimal version is not met, it will probe Pandoc for its version, cache it and return that value.
    If the minimal version is met, it will return the cached version and stop probing Pandoc
    (unless :func:`clean_cache()` is called).

    Raises
    ------
    PandocMissing
      If pandoc is unavailable.
    """
    global __version

    if __version is None:
        if not which('pandoc'):
            raise PandocMissing()

        out = subprocess.check_output(['pandoc', '-v'])
        out_lines = out.splitlines()
        version_pattern = re.compile(r"^\d+(\.\d+){1,}$")
        for tok in out_lines[0].decode('ascii', 'replace').split():
            if version_pattern.match(tok):
                __version = tok
                break
    return __version


def check_pandoc_version():
    """Returns True if pandoc's version meets at least minimal version.

    Raises
    ------
    PandocMissing
      If pandoc is unavailable.
    """
    if check_pandoc_version._cached is not None:
        return check_pandoc_version._cached

    v = get_pandoc_version()
    if v is None:
        warnings.warn("Sorry, we cannot determine the version of pandoc.\n"
                      "Please consider reporting this issue and include the"
                      "output of pandoc --version.\nContinuing...",
                      RuntimeWarning, stacklevel=2)
        return False
    ok = check_version(v, _minimal_version, max_v=_maximal_version)
    check_pandoc_version._cached = ok
    if not ok:
        warnings.warn( "You are using an unsupported version of pandoc (%s).\n" % v +
                       "Your version must be at least (%s) " % _minimal_version +
                       "but less than (%s).\n" % _maximal_version +
                       "Refer to http://pandoc.org/installing.html.\nContinuing with doubts...",
                       RuntimeWarning, stacklevel=2)
    return ok


check_pandoc_version._cached = None


#-----------------------------------------------------------------------------
# Utilities
#-----------------------------------------------------------------------------
def replace_markdown_paths(source, relative_path_replacement, build_path_replacement):
    """Returns source with relative image references prefixed by relative_path_replacement
    and with contents linked or copied to build_path_replacement.
    """

    # TODO: Need a better way to organize or document these?

    # Building blocks for matching `![image](my_diagram.png)` markdown
    img_open_group = r'(!\[[^\]]+\]\()' # `![anything here]`
    no_scheme_ahead = r'(?![^:\.]+:\/\/)' # Blocks `http://`
    slash_match = r'\/'
    no_slash_match = r'[^\/]'
    any_match = r'\.'
    wrapped_path_match = r'[^\)\(\"\']*' # `(capture group here)`
    no_space_match = r'[^ ]'
    img_abs_path_group = (
        r'(' +
        no_scheme_ahead +
        slash_match +
        wrapped_path_match +
        any_match +
        wrapped_path_match +
        no_space_match +
        r')'
    )
    img_rel_path_group = (
        r'(' +
        no_scheme_ahead +
        no_slash_match + # Relative paths aren't prefixed with `/`
        wrapped_path_match +
        any_match +
        wrapped_path_match +
        no_space_match +
        r')'
    )
    img_close_group = r'(\))'

    # Building blocks for matching `[reference]: m_diagram.png` markdown
    ref_open_group = r'(\[[^\]]+\]: ?)' # `[reference]`
    no_slash_or_space_match = r'[^\/ ]'
    no_slash_or_space_or_arrow_match = r'[^\/< ]'
    no_arrow = r'[^<]'
    no_space_or_arrow_match = r'[^< ]'
    many_no_arrow_or_newline_match = r'[^>\n]+' # arrow wrapped path match
    many_no_whitespace_and_no_arrow_match = r'[^\s]+[^>]' # open path match
    arrow_rel_path_ref_match = (
        r'(?:<' +
        no_scheme_ahead +
        no_slash_or_space_match + # Relative paths aren't prefixed with `/`
        many_no_arrow_or_newline_match +
        r'>)'
    )
    open_rel_path_ref_match = (
        r'(?:' +
        no_scheme_ahead +
        no_slash_or_space_or_arrow_match + # Relative paths aren't prefixed with `/`
        many_no_whitespace_and_no_arrow_match +
        r')'
    )
    arrow_abs_path_ref_match = (
        r'(?:<' +
        no_scheme_ahead +
        slash_match +
        no_space_match +
        many_no_arrow_or_newline_match +
        r'>)'
    )
    open_abs_path_ref_match = (
        r'(?:' +
        no_scheme_ahead +
        slash_match +
        no_space_or_arrow_match +
        many_no_whitespace_and_no_arrow_match +
        r')'
    )
    ref_rel_path_group = r'(' + arrow_rel_path_ref_match + '|' + open_rel_path_ref_match + r')'
    ref_abs_path_group = r'(' + arrow_abs_path_ref_match + '|' + open_abs_path_ref_match + r')'
    empty_group = r'()'

    # Building blocks for matching citation ` "My Citation"` markdown
    # (older) Pandoc ignores captions, but we don't want to mangle them when we do path adjustments
    double_quote_label = r'(?:\"[^\"]+\")'
    single_quote_label = r'(?:\'[^\']+\')'
    paren_quote_label = r'(?:\([^\)]+\))'
    any_quote_label = '|'.join((double_quote_label, single_quote_label, paren_quote_label))
    maybe_closed_label_group = r'( (?:' + any_quote_label + r'))?'
    maybe_open_label_group = r'($| (?:' + any_quote_label + r'))'

    # print(img_open_group + img_rel_path_group + maybe_closed_label_group + img_close_group)
    # print(ref_open_group + ref_rel_path_group + maybe_open_label_group)
    # print(img_open_group + img_abs_path_group + maybe_closed_label_group + img_close_group)
    # print(ref_open_group + ref_abs_path_group + maybe_open_label_group)
    # raise Exception("STOP")

    if relative_path_replacement:
        def replace_relative_path_from_groups(m):
            # We can't quote the path for xetex downstream if it has spaces in it
            # See https://tug.org/pipermail/xetex/2009-December/015313.html
            # However the will still render but will double render some path
            # characters alongside the image. To avoid this also use build_path_replacement.
            return (
                m.group(1) + # ![image]( OR [reference]:
                _reapply_path_wrappers(
                    os.path.join(
                        pathname2url(relative_path_replacement),
                        _strip_path_wrappers(m.group(2))),
                    m.group(2)
                ) +
                (m.group(3) or "") + # Maybe "label"
                (m.group(4) or "") # Maybe `)`
            )

        # Image links => https://regex101.com/r/UVeqHs/6
        source = re.sub(img_open_group + img_rel_path_group + maybe_closed_label_group + img_close_group,
            replace_relative_path_from_groups, source)
        # Image references => https://regex101.com/r/tcruDa/9
        source = re.sub(ref_open_group + ref_rel_path_group + maybe_open_label_group + empty_group,
            replace_relative_path_from_groups, source)

    if build_path_replacement:
        def copy_replace_abs_path_from_groups(m):
            # If our file path may have non-alphanumeric characters, the only way
            # for latex targets to correctly parse the files is to rename them in
            # a alphanumeric path.
            print(m)
            print(m.group(3))
            return (
                m.group(1) + # ![image]( OR [reference]:
                _rename_and_copy_to_build_dir(
                    url2pathname(_strip_path_wrappers(m.group(2))),
                    build_path_replacement) +
                (m.group(3) or "") + # Maybe "label"
                (m.group(4) or "") # Maybe `)`
            )

        # Image links => https://regex101.com/r/RFjB4Y/2
        source = re.sub(img_open_group + img_abs_path_group + maybe_closed_label_group + img_close_group,
            copy_replace_abs_path_from_groups, source)
        # Image references => https://regex101.com/r/tuGUJI/4
        source = re.sub(ref_open_group + ref_abs_path_group + maybe_open_label_group + empty_group,
            copy_replace_abs_path_from_groups, source)

    return source

def _reapply_path_wrappers(new_path, old_path):
    for s, e in [('<', '>'), ('"', '"')]:
        if old_path.startswith(s) and old_path.endswith(e):
            return s + new_path + e
    return new_path

def _strip_path_wrappers(path):
    for s, e in [('<', '>'), ('"', '"')]:
        if path.startswith(s) and path.endswith(e):
            return path[1:-1]
    return path

def _rename_and_copy_to_build_dir(filename, build_path):
    """Copies filename to build_path with a latex safe file name"""
    ensure_dir_exists(build_path)
    new_file_path = os.path.join(build_path, os.path.basename(filename))
    # return new_file_path
    safe_file_path = os.path.join(build_path, sensitive_filename_cleanup(os.path.basename(filename)))
    link_or_copy(filename, safe_file_path)
    return safe_file_path


#-----------------------------------------------------------------------------
# Exception handling
#-----------------------------------------------------------------------------
class PandocMissing(ConversionException):
    """Exception raised when Pandoc is missing."""
    def __init__(self, *args, **kwargs):
        super(PandocMissing, self).__init__( "Pandoc wasn't found.\n" +
                                             "Please check that pandoc is installed:\n" +
                                             "http://pandoc.org/installing.html" )

#-----------------------------------------------------------------------------
# Internal state management
#-----------------------------------------------------------------------------
def clean_cache():
    global __version
    __version = None

__version = None
