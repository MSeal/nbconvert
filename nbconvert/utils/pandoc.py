"""Utility for calling pandoc"""
# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import print_function, absolute_import

import subprocess
import warnings
import re
import os
import shutil
from io import TextIOWrapper, BytesIO

from nbconvert.utils.version import check_version
from ipython_genutils.py3compat import cast_bytes, which
from ipython_genutils.path import link_or_copy, ensure_dir_exists
try:
    # Python 2
    from urllib import url2pathname
except ImportError:
    # Python 3
    from urllib.request import url2pathname
try:
    # Python 3
    from urllib.parse import urlparse
except:
    # Python 2
    from urlparse import urlparse

from .exceptions import ConversionException
from .io import sensitive_filename_cleanup

_minimal_version = "1.12.1"
_maximal_version = "3.0.0"


def pandoc(source, fmt, to, extra_args=None, encoding='utf-8',
           relative_path_replacement=None, build_path_replacement=None):
    """Convert an input string using pandoc.

    Pandoc converts an input string `from` a format `to` a target format.

    Parameters
    ----------
    source : string
      Input string, assumed to be valid format `from`.
    fmt : string
      The name of the input format (markdown, etc.)
    to : string
      The name of the output format (html, etc.)
    extra_args : list (optional)
      Extra Pandoc command arguments.
    relative_path_replacement : string (optional)
      The path to use in replacing relative paths.
    build_path_replacement : string (optional)
      A path to copy files into and reference in any image paths.

    Returns
    -------
    out : unicode
      Output as returned by pandoc.

    Raises
    ------
    PandocMissing
      If pandoc is not installed.

    Any error messages generated by pandoc are printed to stderr.

    """
    cmd = ['pandoc', '-f', fmt, '-t', to]
    if extra_args:
        cmd.extend(extra_args)

    # This will raise an exception that will pop us out of here
    check_pandoc_version()

    # For markdown formats we can manipulate image paths to correct for latex issues
    if 'markdown' in fmt:
        source = replace_markdown_paths(
            source, relative_path_replacement, build_path_replacement)

    p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    out, _ = p.communicate(cast_bytes(source, encoding))
    out = TextIOWrapper(BytesIO(out), encoding, 'replace').read()
    return out.rstrip('\n')


def get_pandoc_version():
    """Gets the Pandoc version if Pandoc is installed.

    If the minimal version is not met, it will probe Pandoc for its version, cache it and return that value.
    If the minimal version is met, it will return the cached version and stop probing Pandoc
    (unless :func:`clean_cache()` is called).

    Raises
    ------
    PandocMissing
      If pandoc is unavailable.
    """
    global __version

    if __version is None:
        if not which('pandoc'):
            raise PandocMissing()

        out = subprocess.check_output(['pandoc', '-v'])
        out_lines = out.splitlines()
        version_pattern = re.compile(r"^\d+(\.\d+){1,}$")
        for tok in out_lines[0].decode('ascii', 'replace').split():
            if version_pattern.match(tok):
                __version = tok
                break
    return __version


def check_pandoc_version():
    """Returns True if pandoc's version meets at least minimal version.

    Raises
    ------
    PandocMissing
      If pandoc is unavailable.
    """
    if check_pandoc_version._cached is not None:
        return check_pandoc_version._cached

    v = get_pandoc_version()
    if v is None:
        warnings.warn("Sorry, we cannot determine the version of pandoc.\n"
                      "Please consider reporting this issue and include the"
                      "output of pandoc --version.\nContinuing...",
                      RuntimeWarning, stacklevel=2)
        return False
    ok = check_version(v, _minimal_version, max_v=_maximal_version)
    check_pandoc_version._cached = ok
    if not ok:
        warnings.warn( "You are using an unsupported version of pandoc (%s).\n" % v +
                       "Your version must be at least (%s) " % _minimal_version +
                       "but less than (%s).\n" % _maximal_version +
                       "Refer to http://pandoc.org/installing.html.\nContinuing with doubts...",
                       RuntimeWarning, stacklevel=2)
    return ok


check_pandoc_version._cached = None


#-----------------------------------------------------------------------------
# Markdown Utilities
#-----------------------------------------------------------------------------
def replace_markdown_paths(source, relative_path_replacement=None, build_path_replacement=None):
    """
    Finds and replaces markdown any markdown image links `![image](path/to/image.png)`
    or image references `[ref]: path/to/image.png` in the source.

    If relative_path_replacement is passed, then each identified relative image path
    will have relative_path_replacement prepended to the path. With relative_path_replacement
    having a value of `/abs` the following transformations will occur:

    `![image](path/to/image.png)` -> `![image](/abs/path/to/image.png)`
    `[ref]: path/to/image.png` -> `[ref]: /abs/path/to/image.png`

    If build_path_replacement is passed, then each identified image path will be
    copied to the build_path_replacement directory and renamed to a latex safe file name.
    With build_path_replacement having a value of `/tmp/foo` the following transformations
    will occur:

    `![image](path/to/space in image.png)` -> `![image](/tmp/foo/space_in_image.png)`
    `[ref]: path/to/image.png` -> `[ref]: /tmp/foo/space_in_image.png`

    Returns
    -------
    replaced : unicode
      The source with the described transformations applied.
    """

    # https://regex101.com/r/wZwqo1/1
    image_link_group = r'(!\[[^\]]+\]\([^\n\)]+\)\)?)'
    # https://regex101.com/r/9GVffV/4
    image_reference_group = r'^(\s*)(\[[^\]]+\]: ?.+)$'

    if relative_path_replacement:
        # Replace relative paths in ![images]
        source = re.sub(
            image_link_group,
            lambda m: _prefix_relative_image_path(m.group(0), relative_path_replacement),
            source,
            flags=re.M)
        # Replace relative paths in [references]
        source = re.sub(
            image_reference_group,
            lambda m: _prefix_relative_image_reference_path(m.group(0), m.group(1), relative_path_replacement),
            source,
            flags=re.M)

    if build_path_replacement:
        # Replace paths in ![images]
        source = re.sub(
            image_link_group,
            lambda m: _rename_and_copy_image_path(m.group(0), build_path_replacement),
            source,
            flags=re.M)
        # Replace paths in [references]
        source = re.sub(
            image_reference_group,
            lambda m: _rename_and_copy_image_reference_path(m.group(0), m.group(1), build_path_replacement),
            source,
            flags=re.M)

    return source

def _prefix_relative_image_path(image_match, relative_path_replacement):
    """
    For an image string of the shape `![image](path/to/image)`, replace the relative
    path with value of relative_path_replacement (e.g. `![image](/abs/path/to/image)`).
    """
    image_tag = _extract_tag(image_match)
    image, label = _extract_image_and_label(image_match)
    parsed = urlparse(image)
    if parsed.scheme or parsed.path.startswith('/'):
        # Skip out, we aren't parsing absolute or schema'd paths
        return image_match
    new_path = os.path.join(relative_path_replacement, image)
    # Combine our pieces back together
    return "![{tag}]({path}{label})".format(
        tag=image_tag, path=new_path, label=' ' + label if label else ''
    )

def _prefix_relative_image_reference_path(image_match, white_space, relative_path_replacement):
    """
    For a reference string of the shape `[ref]: path/to/image.png`, replace the relative
    path with value of relative_path_replacement (e.g. `[image]: /abs/path/to/image.png`).
    """
    ref_tag = _extract_tag(image_match)
    image, label = _extract_reference_and_label(image_match)
    image_start, image_end = "", ""
    if (image.startswith("<") and not image.endswith(">")) or (
        not image.startswith("<") and image.endswith(">")):
        # Skip out, not a valid image reference
        return image_match
    elif image.startswith("<"):
        image_start, image_end = "<", ">"
        image = image[1:-1]
    parsed = urlparse(image)
    if parsed.scheme or parsed.path.startswith('/'):
        # Skip out, we aren't parsing absolute or schema'd paths
        return image_match
    new_path = image_start + os.path.join(relative_path_replacement, image) + image_end
    # Combine our pieces back together
    return "{ws}[{tag}]: {path}{label}".format(
        ws=white_space, tag=ref_tag, path=new_path, label=' ' + label if label else ''
    )

def _rename_and_copy_image_path(image_match, build_path_replacement):
    """
    For an image string of the shape `![image](/abs/path/to/space image.png)`, copy the file
    contents into the build path and rename the file (e.g. `![image](/build/space_image.png)`).
    """
    image_tag = _extract_tag(image_match)
    image, label = _extract_image_and_label(image_match)
    parsed = urlparse(image)
    if parsed.scheme:
        # Skip out, we aren't parsing schema'd paths
        # TODO: Handle remote urls here for https:// link generation in pdfs
        return image_match
    # url2pathname to convert %20 in notebook image links
    new_path = _rename_and_copy_to_build_dir(url2pathname(image), build_path_replacement)
    # Combine our pieces back together
    return "![{tag}]({path}{label})".format(
        tag=image_tag, path=new_path, label=' ' + label if label else ''
    )


def _rename_and_copy_image_reference_path(image_match, white_space, build_path_replacement):
    """
    For an reference string of the shape `[ref]: /abs/path/to/space image.png`, copy the file
    contents into the build path and rename the file (e.g. `[ref]: /build/space_image.png`).
    """
    ref_tag = _extract_tag(image_match)
    image, label = _extract_reference_and_label(image_match)
    image_start, image_end = "", ""
    if (image.startswith("<") and not image.endswith(">")) or (
        not image.startswith("<") and image.endswith(">")):
        # Skip out, not a valid image reference
        return image_match
    elif image.startswith("<"):
        image_start, image_end = "<", ">"
        image = image[1:-1]
    parsed = urlparse(image)
    if parsed.scheme:
        # Skip out, we aren't parsing schema'd paths
        # TODO: Handle remote urls here for https:// link generation in pdfs
        return image_match
    new_path = (
        image_start +
        # url2pathname to convert %20 in notebook image links
        _rename_and_copy_to_build_dir(url2pathname(image), build_path_replacement) +
        image_end
    )
    # Combine our pieces back together
    return "{ws}[{tag}]: {path}{label}".format(
        ws=white_space, tag=ref_tag, path=new_path, label=' ' + label if label else ''
    )

def _extract_tag(markdown_link):
    """
    Pulls the tag out of `![tag](other stuff)` strings.
    """
    return markdown_link.split('[', 1)[-1].split(']', 1)[0]

def _split_image_and_label(img_with_label):
    """
    Separates the image `path/to/image.png` and label `important` from
    `path/to/image.png "important"` strings.
    """
    for label_start, label_end in [('"', '"'), ("'", "'"), ("(", ")")]:
        if img_with_label[-1] == label_end:
            image, label = img_with_label[:-1].split(label_start, 1)
            return image.strip(), label_start + label + label_end
    return img_with_label, None

def _extract_image_and_label(markdown_link):
    """
    Pulls the image `path/to/image.png` and label `important` out of
    `![tag](path/to/image.png "important")` strings.
    """
    img_with_label = markdown_link.split('](', 1)[-1].rsplit(')', 1)[0].strip()
    return _split_image_and_label(img_with_label)

def _extract_reference_and_label(markdown_link):
    """
    Pulls the image `path/to/image.png` and label `important` out of
    `[tag]: path/to/image.png "important"` strings.
    """
    img_with_label = markdown_link.split(']:', 1)[-1].strip()
    return _split_image_and_label(img_with_label)

def _rename_and_copy_to_build_dir(filename, build_path_replacement):
    """Copies filename to build_path with a latex safe file name"""
    ensure_dir_exists(build_path_replacement)
    new_file_path = os.path.join(
        build_path_replacement, os.path.basename(filename))
    # return new_file_path
    safe_file_path = os.path.join(
        build_path_replacement, sensitive_filename_cleanup(os.path.basename(filename)))
    link_or_copy(filename, safe_file_path)
    return safe_file_path


#-----------------------------------------------------------------------------
# Exception handling
#-----------------------------------------------------------------------------
class PandocMissing(ConversionException):
    """Exception raised when Pandoc is missing."""
    def __init__(self, *args, **kwargs):
        super(PandocMissing, self).__init__( "Pandoc wasn't found.\n" +
                                             "Please check that pandoc is installed:\n" +
                                             "http://pandoc.org/installing.html" )

#-----------------------------------------------------------------------------
# Internal state management
#-----------------------------------------------------------------------------
def clean_cache():
    global __version
    __version = None

__version = None
